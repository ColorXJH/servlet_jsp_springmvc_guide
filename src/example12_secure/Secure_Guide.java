package example12_secure;

public class Secure_Guide {
		//安全
			//下面四个问题是网络安全的基石
				//1：认证
				//2：授权
				//3：保密性
				//4：数据完整性
			
			//1：身份认证是验证网络实体的身份，特别是用户尝试访问应用程序，通常用用户名和密码来验证身份
			//2：授权通常是在与访问级别的身份认证的用户认证成功之后进行的，它试图回答一个问题：一个经过验证的用户可以进入应用程序的某个取域吗？
			//3：保密性是一个重要话题
			//4：在互联网上传输一些关键数据需要加密也可以确保敏感数据经过安全通道传输
		//SSL:用于在因特网中创建安全通道的协议
	
	//身份认证和授权
		//在一个Servlet/JSP应用程序中，身份验证一般通过检查用户名密码是否正确。授权是检查该级别的用户是否具备访问权限
		//访问级别通常被称为角色
			//在部署一个servlet/jsp应用程序时可以方便的通过模块分类和配置，使得每个模块只有特定角色才能访问，这是通过在部署中声明安全约束描述符完成的（声明式安全）
		//使用声明式安全可让您的编程更简洁，因为Servlet/JSP容器负责身份验证和授权过程。此外，Servlet/JSP容器配置数据库来验证你已经在应用程序中使用
		//使用声明式身份验证的用户名和密码可在被发送到服务器之前由浏览器对其加密后再发送给服务器
		//缺点是：支持数据加密的身份认证方法只能使用一个默认的登陆对话框，不能指定个性化的登陆界面，它允许一个自定义的html表单，但是数据传输不加密
		//web应用的某些部分，如管理模块，不是面向客户的，所以登陆表单的外观是没有关联的，这中情况下，声明式安全任然被使用
		//声明式安全的有趣部分是安全约束不编入servlet了，，相反，他们再应用程序部署时声明在部署描述符中，
	
		//要使用声明式安全，需要定义用户和角色,根据使用的容器，可以将用户和角色信息存储在文件或数据库表中
		//仙子啊如何不通过编程来验证用户，答案在于http而不是servlet规范
		
		//指定用户和角色
			//一个兼容servlet/jsp容器必须提供一个定义用户和角色的方法，如果使用tomcat，可以通过编辑conf目录中的Tomcat-user.xml来创建用户和角色

		
		//实施安全约束
			//把静态资源和jsp页面放入web-inf目录下可以隐藏起来，资源放置在这里不能通过url直接访问，仍然可以从一个servlet或jsp页面进入
			//缺点是：资源隐藏在这里永远是隐藏的，没有办法直接访问，如果你只是希望简单的像保护资源不被未经授权的用户访问，可以把他们放在应用程序的目录的下一个目录中，在部署描述符中声明一个安全约束
			
			//security-constraint指定一个资源集合和角色或角色可以访问的资源，这个元素由两个子元素
				//1：web-resource-collection:指定一组资源，可以包括web-resource-name,description,url-pattern,http-method,http-method-ommission
					//可以有多个url模式子元素，每一个都是指一个url正则表达式，可以指定特定资源类型(*.jsp),或特定资源目录(/*或/jsp/*),但是不能同时指定两个(/jsp/*.jsp),相反，使用/jsp/*也将限制任何在jsp目录下的非jsp页面
					//http-method元素为封闭的安全约束命名了一个http方法，例如一个web-resource-collection元素以GET http-method命名，标识该元素仅适合http get方法，没有此元素标识限制了所有的http方法
					//http-method-omission元素指定一个不包含http方法的安全约束：<http-method-omission>GET</http-method-omission标识限制GET以外的所有http方法
				//2:auth-constraint
				//部署描述符中可以有多个security-constraint元素。如果security-constraint没有auth-constraint元素，那么这个资源集合是不被保护的



		//如何对用户进行身份认证和授权
			//知道了如何实施资源集合的安全约束之后，也应该学会如何验证访问资源的用户信息
			//身份认证可以使用http1.1提供的解决方案：基本访问认证和摘要访问身份认证
			//也可以使用基于表单的访问认证
				//1：基本访问身份认证(也可以配置连接数据库)
					//是一个接收用户名和密码的http身份认证，受访问保护的资源的用户将被服务器拒绝，服务返回401，浏览器会显示用户名和密码的登陆对话框。
					//当点击登陆时，用户名被加上一个冒号连同密码形成一个字符串，该字符串在被发到服务器之前将采用Base64算法编码，登陆成功后服务器将发送所请求的资源，这个访问算法比较脆弱，通常使用摘要访问认证来替代
				//2：摘要访问接入认证(也可以配置连接数据库)
					//摘要认证也是一个http认证，但是不是使用若加密的base64算法，而是使用MD5算法创建一个组合用户名，域名和密码的哈希值，并发送到服务器
					//jsp/servlet容器没有义务支持摘要认证但大多数都有做
						//步骤如下
							//1：首先在数据库创建两张表，分别存放用户的身份(用户名/密码)和权限(角色role)
							//2:在tomcat的server.xml文件中注释掉原来的realm(数据源)，加入jdbc支持的数据库数据源，并标记驱动名，连接url,两个表和对应的字段映射，注意要在tomcat的类路径下加入mysql/oracle的驱动包（不是在类路径下）
							//3：在配置描述符web.xml文件中需要添加资源限制集合元素和登陆配置元素
				//3:基于表单的认证
					//基本和摘要访问认证不允许你人用一个自定义的登陆表单，如果你必须有一个登陆窗体，那么你可以使用基于表单的认证，
					//由于发送名文，你应该配合SSL使用
						//你需要创建一个登陆页面和一个错误页面，可以是jsp/html页面
							//第一次请求受保护的资源时，servlet/jsp容器将访问登陆页面，登陆成功，所请求的资源被发送，登陆失败，会返回到错误页面
						//使用form-based authentication,部署描述符的auth-method元素的值必须时FORM(大写)，login-config元素必须有form-login-config元素节点，该节点有两个子节点：form-login-page,form-error-page
				
			//客户端证书认证：
				//也成为client-cert认证，客户端证书身份通过hhttps（http通过ssl）认证，要求每个客户有一个客户端证书
				//这是一个非常强大的认证机制，但是不适合在互联网上部署的应用程序，因为它不切实际的要求每个用户自己的数字证书
				//然而这种身份验证方法可以用来访问组织内部的应用
	
			//安全套接层
				//SSL(secure socket layer)为netscape所研发，用于保障在internet上数据传输的安全，利用数据加密技术，可以确保数据在网络传递的过程中不被截取及侦听
				//充分理解ssl需要理解加密，私钥和公钥对，证书等
				
				//密码学
					//在开始的时候，人们使用对称密码加密和解密消息（使用相同的密钥来加密和揭秘数据）
					//对称加密不适合互联网的原因如下：
						//1两人交换信息通常不知道对方
						//每个人都希望与其他各方沟通
						//你不知道你要通信的实体你需要确定他们的真实身份
						//信息在互联网上通过许多计算机传播
					//因此今天的互联网通信使用非对称加密，有如下三个特点：
						//1：加密/解密：信息对第三方进行加密隐藏，只有于其的接收者才能解密
						//2：身份验证：验证确保实体就是声称者
						//3：数据的完整性：许多计算机在互联网上发送的消息传递，他必须确保发送的数据不变完好无损
							//非堆成加密过程中，使用公钥加密，这种类型的加密，加密和解密的数据是通过使用一对非对称密钥：公钥和私钥，私钥是私有的	
							//颁发者必须保证它在一个安全的地方，它不能落入任何一方的手里，公钥分发给公众，通常谁都可以下载这个密钥与颁发者沟通，你可以使用工具来生成公钥和私钥
								//优点：使用公共密钥加密的数据只能使用对应的私钥进行解密，在童谣使用私钥进行加密的数据只能使用对应的公钥进行解密，他们简称为RSA算法
	
							//RSA算法在互联网上被实践证明：特别是电子商务，因为只有供应商要求有一个密钥对所有的买家进行通信
	
					//加密和解密：
						//交换信息的一方必须有一个密钥对，如果爱丽丝想和鲍勃交流，鲍勃有公共密钥和私有密钥，鲍勃将公钥发送给爱丽丝，爱丽丝可以用它来加密发送给鲍勃的消息，只有鲍勃可以解密，因为他有对应的私钥，鲍勃若想要发送消息给爱丽丝
						//，则使用自己的私钥加密消息，爱丽丝可以用鲍勃的公钥解密消息，然而要交出公钥，除非鲍勃可以与爱丽丝见面，否则这种方法并不完美，有一对密钥的任何人都可以声称自己是鲍勃，爱丽丝无法辨认
					//认证：
						//ssl身份认证是通过引入证书，证书包含以下几个：
							//1；公钥
							//2：关于主题的信息，即公开密钥的所有者
							//3：证书发行机构的名称
							//4：证书到期时间的时间戳
						//关于证书，重要的是他必须由一个可信的数字签名证书颁发者，如versign或thawte,对电子文件进行数字签名是你的文档文件中添加了你的签名，原始文件
						//没有加密，和签名的真正目的是为了保证文件没有被串改，签属一个文件设计创建一个文档的摘要，并使用签名者的私钥对摘要进行加密，要检查文档是否还是原来的状态，你需要执行两个步骤
							//1：使用签名者的公钥解密伴随文件摘要，你很快就会发现，一个受信任的证书发行者的公钥很容易获得
							//2：创建一个文档摘要
							//3：比较步骤1，2的结果，如果两者匹配，则文件没有被串改
						//由于证书可以由受信任的颁发者签名，所有人们常常发布证书而不是公钥
							//要申请一个证书，鲍勃要产生一对密钥，把自己的公钥发送给证书颁发者，后者私用私钥来对证书签名（加密	），因此证书只能通过发放这的公钥来读取，有许多证书发布者的公钥是嵌入在浏览器中的
								//爱丽丝东证书得到鲍勃的公钥，证书使用证书颁发者的私钥签名，现在爱丽丝得到了公钥，，消息和使用私钥加密的摘要，爱丽丝通过使用公钥生成摘要来比对用公钥解密原始证书上私钥加密的摘要是否一致来判断对方身份，
								//一旦安全通信建立之后，ssL使用对称加密。因为他比非对称加密快很多
	
					//数据的完成性
						//现在还有一个事件的缺失在这个加密传输过程中，互联网上传递消息有多台计算机，你如何确保这些信息的完整性，因为任何人都可以拦截这些信息
						//加入在爱丽丝和鲍勃的中间有一个玛丽，他是一个恶意方，虽然他不能破译传递的信息，但是他能破坏这些信息或者不传递一些信息给对方，为了克服这个消息
						//ssl引入了消息验证码（mac）,mac是用一个密钥和传输的数据计算出的数据块，因为玛丽不知道密钥，所以她不能正确计算摘要，消息接收器可以因此发现数据的不完整性，如果发生这种情况，双发可以停止沟通，
						//MD5是其中一个这样的消息摘要算法，是由RSA发明的
	
					//SSL是怎么工作的
						//亚马逊，和其他任何真正的电子商务供应商一样，它以向受信任的证书颁发者，申请了证书，买方使用IE浏览器，它潜入了可信证书发行机构的公钥
						//买方那个并不真的需要直到ssl如何工作，它需要保证的一件事是，当进入中哟啊的细节时，如输入信用卡号时，使用的协议必须是https来代替http
								//浏览器：你真的是亚马逊吗？
								//服务器：是的，这是我的证书
								//（浏览器：使用发行者证书的公钥来解密查看证书的有效性（比如查看摘要是否一致），如果出现什么错误，如证书过期，浏览器将警告用户，如果用户继续同意则浏览器将继续执行下去）
								//浏览器：单独有证书是不够的，请给一些别的东西
								//服务器：“我真的是亚马逊”（使用亚马逊网站的私钥加密同一消息摘要）
								//浏览器：使用亚马逊的公钥解密摘要，并创建“我真的是亚马逊”的摘要，如果两者匹配成功则验证通过，然后浏览器就会长生一个随机密钥，使用亚马逊的公钥加密，这个随即密钥用来加密和解密随后的消息（一旦通过加密认证，将使用对称加密技术传输数据）
	
					//编程式安全
						//你可以在httpservletrequest接口使用安全注释类型和方法
						
						//安全注释类型
							//在上一节中学会了使用security-constraint元素集合来限定资源访问，servlet3提供的注解可以在一个servlet级别执行相同的操作
							//使用费这些注解类型可以限制访问一个servlet,而不用在部署描述符中使用security-constraint元素，但是你仍然需要一个login-config元素的部署描述符来选择一个身份验证方法
							//在javax.servlet.annotation包中有三个安全相关的注解类型
								//1：ServletSecurity:用在一个sevlet类上用于强制安全约束，一个servlet安全注解可能有值和httpMethodConstraint属性
								//2:HttpConstraint：定义了安全约束，只能分配给ServletSecurity注解的值属性
								//3:HttpMethodConstraint：若此属性不存在于servletsecurity注解内，则此注解施加的安全约束适用于所有http方法
										//@ServletSecurity(value=@HttpConstraint(rolesAllowed="manage"))====@ServletSecurity(@HttpConstraint(rolesAllowed="manager"))
										//设置transportGuarantee.confidential的httpConstraint标注到transportGuarantee属性使servlet,使servlet只能通过秘密通道，如ssl
											//@ServletSecurity(@HttpConstraint(transportGuarantee=transportGuarantee.CONFIDENTIAL))
												//如果servlet和jsp容器接受这样一个servlet通过http请求时，他将浏览器重定向到https版本相同的url
												//@ServletSecurity(httpMethodConstraint={@HttpMethodConstraint(value="GET",rolesAllowed="manager")})//限制通过http-get访问该servlet的manager角色,对于其他方法则不限制
												//@ServletSecurity(value=@HttpConstraint(rolesAllowed="manager"),httpMethodConstraints={@HttpConstraint("GET")})//可以被任何用户通过get方法访问，但是除了get之外的方法只能被限制于经理的角色访问
												//@ServletSecurity(value=@HttpConstraint(rolesAllowed="member"),httpMethodConstraints={@HttpMethodConstraint(value="GET",emptyRolesSemantic=EmptyRolesSemantic.DENY)})//防止通过get方法访问，但是允许所有用户成员角色通过其他http方法访问
						
						//Servlet的安全API
							//除了在上一节讨论的注解类型，程序的安全性也可以在HttpServletRequest接口使用以下方法实现
								//java.lang.String getAuthType():返回用来保护servlet认证方案，如果没有安全约束则返回空
								//java.lang.String getRemoteUser()返回发出此请求登陆用户，如果尚未验证则返回空
								//bollean isUserInRole(String role)返回一个只是角色是否属于当前用户
								//java.lang.Principal getUserPrincipal():返回包含当前通过验证的用户的细节信息java.lang.Principal，如果没有认证则返回空
								//boolean authenticate(HttpservletResponse response) throws IOException  通过指示浏览器显示登陆表达那来验证用户
								//void login(String userName,String password) throws javax.servlet.ServletException，试图使用所提供的用户名和密码进行登陆，该方法没有返回结果，如果登陆失败则抛出异常
								//void logout() throws javax.servletServletException  注销用户
	
					//小结：网络安全的4大支柱：身份验证，授权，保密性，数据完整性
					//servlet允许你以声明或编程的方式保护你的应用程序
	
	
	
	
	
	
	
	

}
